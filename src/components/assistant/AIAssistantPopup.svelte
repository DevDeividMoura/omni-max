<script lang="ts">
  import { onMount, onDestroy } from "svelte";
  import { marked } from "marked";
  import { ChevronDown, X, ArrowUp, Plug } from "lucide-svelte";

  import { assistantPopupStore } from "./assistantPopupStore";
  import PersonaSelectorPopup from "./PersonaSelectorPopup.svelte";
  import { agentChatStore } from "./agentChatStore";
  import { personasStore, type Persona } from "../../storage/stores";

  import MCPServersPopup from "./MCPServersPopup.svelte";
  import type { Translator } from "../../i18n/translator.content";
  import type { AgentService } from "../../content/services/AgentService";

  // --- Props (Servi√ßos injetados pelo AssistantUiService) ---
  export let translator: Translator;
  export let agentService: AgentService;

  // --- Store Auto-Subscriptions ---
  $: assistantState = $assistantPopupStore;
  $: allChats = $agentChatStore;
  $: availablePersonas = $personasStore;

  // --- Reactive Variables (CORRECTED) ---
  $: isVisible = assistantState.isVisible;
  $: context = assistantState.context;
  $: protocolNumber = context?.protocolNumber ?? null;

  $: currentChat = protocolNumber
    ? allChats[protocolNumber] || { messages: [] }
    : { messages: [] };
  $: messages = currentChat.messages;

  // NEW LOGIC: Determine if the agent is thinking by inspecting the LAST message.
  $: isAgentThinking =
    messages.length > 0 &&
    messages[messages.length - 1].type === "ai" &&
    messages[messages.length - 1].isThinking === true;

  // --- Component's Internal State ---
  let streamingContent = '';
  let inputValue = "";
  let isMCPPopupOpen = false;
  let selectedPersonaId: string | undefined;
  let translations = {
    title: "...",
    thinking: "...",
    assistantName: "...",
    typeYourQuery: "...",
    howCanIHelp: "...",
    chooseOrType: "...",
  };
  let extensionIconUrl = "";
  let t: (key: string, options?: any) => Promise<string>;
  let contentAreaEl: HTMLElement;
  let textareaEl: HTMLTextAreaElement;
  let isPersonaPopupOpen = false;

  const suggestions = [
    {
      id: "summarize",
      icon: "üìÑ",
      titleKey: "assistant.suggestions.summarize",
      descriptionKey: "assistant.suggestions.summarize_desc",
      promptKey: "assistant.suggestions.summarize_prompt_text",
    },
    {
      id: "extract_actions",
      icon: "‚úÖ",
      titleKey: "assistant.suggestions.extract_actions",
      descriptionKey: "assistant.suggestions.extract_actions_desc",
      promptKey: "assistant.suggestions.extract_actions_prompt_text",
    },
  ];

  // --- Lifecycle and Listeners ---
  onMount(async () => {
    extensionIconUrl = chrome.runtime.getURL("src/assets/icons/icon-48.png");
    t = (key, options) => translator.t(key, options);

    translations.title = await t("assistant.title");
    translations.thinking = await t("assistant.thinking");
    translations.assistantName = await t("assistant.assistant_name");
    translations.typeYourQuery = await t("assistant.type_your_query");
    translations.howCanIHelp = await t("assistant.how_can_i_help");
    translations.chooseOrType = await t("assistant.choose_or_type");

    if (availablePersonas.length > 0) {
      selectedPersonaId = availablePersonas[0].id;
    }

    chrome.runtime.onMessage.addListener(handleBackgroundMessage);
  });

  $: if (typeof document !== "undefined") {
    if (isVisible) {
      document.body.style.overflow = "hidden";
      scrollToBottom(); // Scroll to bottom when popup opens
    } else {
      document.body.style.overflow = ""; // Restaura o padr√£o
    }
  }

  onDestroy(() => {
    if (typeof document !== "undefined") {
      document.body.style.overflow = "";
    }
    cleanup(); // Sua fun√ß√£o de cleanup existente
  });

  function cleanup() {
    chrome.runtime.onMessage.removeListener(handleBackgroundMessage);
  }

  /**
   * Waits for the next DOM update and then scrolls the chat area to the bottom.
   */
  function scrollToBottom() {
    requestAnimationFrame(() => {
      if (contentAreaEl) {
        contentAreaEl.scrollTop = contentAreaEl.scrollHeight;
      }
    });
  }

  // --- Event Handlers ---
  async function handleBackgroundMessage(message: any) {
    if (message.context?.protocolNumber !== protocolNumber) return;
    // if (!message.type || !['agentChunk', 'agentStreamEnd', 'agentError'].includes(message.type)) return;
    if (!protocolNumber) return;
        
    switch (message.type) {
      case 'agentTokenChunk':
        // Acumula o conte√∫do recebido
        streamingContent += message.token;
        const formattedStream = await marked.parse(streamingContent);
        console.log("Received token chunk:", message.token);
        // Atualiza a UI com o conte√∫do acumulado
        agentChatStore.updateLastAiMessage(protocolNumber, formattedStream, message.messageId); 
        console.log("Updated AI message with streaming content.");
        scrollToBottom();
        break;

      case 'agentToolEnd':
        // Limpa o acumulador de streaming para a pr√≥xima resposta do LLM
        streamingContent = ''; 
        const toolResultContent = `*Ferramenta ${message.toolName} retornou:* \n \`\`\`\n${message.toolOutput}\n\`\`\``;
        console.log("Tool result content:", toolResultContent);
        const formattedToolResult = await marked.parse(toolResultContent);
        // Atualiza a bolha da IA com o resultado da ferramenta e adiciona um novo placeholder
        agentChatStore.updateLastAiMessage(protocolNumber, formattedToolResult);
        console.log("Updated AI message with tool result.");
        agentChatStore.addEmptyAiMessage(protocolNumber);
        console.log("Added new placeholder for next AI message.");
        scrollToBottom();
        break;
      
      case 'agentStreamEnd':
        // Finaliza a √∫ltima mensagem e limpa o acumulador
        streamingContent = ''; 
        agentChatStore.finalizeLastAiMessage(protocolNumber);
        console.log("Agent stream finished.");
        break;

      case 'agentError':
        // ... (tratamento de erro) ...
        streamingContent = ''; 
        agentChatStore.finalizeLastAiMessage(protocolNumber);
        console.error("Agent error:", message.error);
        break;
    }
  }

 /**
   * NOVA FUN√á√ÉO CENTRALIZADORA
   * Esta fun√ß√£o agora cont√©m toda a l√≥gica de chamar o agente e tratar a resposta.
   * @param agentQuery O prompt/query que ser√° enviado para o backend.
   * @param displayMessage A mensagem que ser√° exibida na UI para o usu√°rio.
   */
  async function _invokeAgentAndHandleResponse(agentQuery: string, displayMessage: string) {
    if (!agentQuery.trim() || !context || !protocolNumber) return;
    if (!selectedPersonaId) {
      console.warn("Nenhuma persona selecionada. Usando a padr√£o.");
      selectedPersonaId = availablePersonas[0]?.id; // Usa a primeira persona dispon√≠vel
    }

    // Limpa o acumulador de streaming antes de uma nova invoca√ß√£o
    streamingContent = '';

    const formattedDisplay = await marked.parse(displayMessage);
    agentChatStore.addUserMessage(protocolNumber, formattedDisplay);
    agentChatStore.addEmptyAiMessage(protocolNumber);
    scrollToBottom();
    
    agentService.invoke({
      context,
      query: agentQuery,
      personaId: selectedPersonaId,
    });
  }
  /**
   * FUN√á√ÉO REATORADA: Agora ela apenas delega para a fun√ß√£o central.
   */
  async function handleSendMessage(query: string) {
    // Limpa a UI
    inputValue = "";
    if (textareaEl) textareaEl.style.height = "auto";
    
    // A query digitada √© tanto o que o agente recebe quanto o que o usu√°rio v√™.
    await _invokeAgentAndHandleResponse(query, query);
  }

  /**
   * FUN√á√ÉO REATORADA: Agora ela tamb√©m apenas delega para a fun√ß√£o central.
   */
  async function handleSuggestionClick(suggestion: (typeof suggestions)[0]) {
    if (!context || !protocolNumber || !selectedPersonaId) return;

    // Prepara as duas vers√µes da mensagem
    const hiddenPrompt = await t(suggestion.promptKey); // Para o agente
    const userFacingMessage = await t(suggestion.titleKey); // Para a UI

    // Chama a fun√ß√£o central com os par√¢metros corretos
    await _invokeAgentAndHandleResponse(hiddenPrompt, userFacingMessage);
  }

  function handlePersonaSelect(selectedId: string) {
    selectedPersonaId = selectedId; // Atualiza o ID
    isPersonaPopupOpen = false; // Fecha o popup
    handlePersonaChange(); // Notifica o agente da mudan√ßa (fun√ß√£o que j√° existe)
  }

  async function handlePersonaChange() {
    if (!selectedPersonaId || !context) return;
    await agentService.changePersona({
      context,
      newPersonaId: selectedPersonaId,
    });
  }

  function hide() {
    assistantPopupStore.hide();
  }

  const handleEscapeKey = (event: KeyboardEvent) => {
    if (event.key === "Escape" && isVisible) hide();
  };

  const handleTextareaKeyDown = (e: KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage(inputValue);
    }
  };

  /**
   * Ajusta a altura da textarea dinamicamente com base no seu conte√∫do.
   */
  function autoResizeTextarea(event: Event) {
    const textarea = event.target as HTMLTextAreaElement;
    // Reseta a altura para o browser recalcular o scrollHeight
    textarea.style.height = "auto";
    // Define a altura para o tamanho total do conte√∫do
    textarea.style.height = `${textarea.scrollHeight}px`;
  }
</script>

<svelte:window on:keydown={handleEscapeKey} />

{#if isVisible}
  <div class="popup-overlay" on:click={hide} role="presentation">
    <!-- svelte-ignore a11y_click_events_have_key_events -->
    <!-- svelte-ignore a11y_no_static_element_interactions -->
    <div class="popup-wrapper" on:click|stopPropagation>
      <div class="popup-header">
        <span class="header-title">
          {#if protocolNumber}{translations.title}: {protocolNumber}{:else}{translations.title}{/if}
        </span>
        <div class="header-controls">
          <button on:click={hide} title="Fechar"><X size={16} /></button>
        </div>
      </div>

      <div class="content-area" bind:this={contentAreaEl}>
        {#if messages.length === 0}
          <div class="welcome-state">
            <div class="welcome-icon-wrapper">
              <img src={extensionIconUrl} alt="Omni Max Logo" />
            </div>
            <div>
              <h2 class="welcome-title">{translations.howCanIHelp}</h2>
              <p class="welcome-subtitle">{translations.chooseOrType}</p>
            </div>
            <div class="suggestions-list">
              {#each suggestions as suggestion (suggestion.id)}
                <button
                  class="suggestion-item"
                  on:click={() => handleSuggestionClick(suggestion)}
                >
                  <div class="suggestion-item-inner">
                    <span class="suggestion-icon">{suggestion.icon}</span>
                    <div>
                      <div class="suggestion-title">
                        {#await t(suggestion.titleKey) then title}{title}{/await}
                      </div>
                      <div class="suggestion-description">
                        {#await t(suggestion.descriptionKey) then desc}{desc}{/await}
                      </div>
                    </div>
                  </div>
                </button>
              {/each}
            </div>
          </div>
        {:else}
          <div class="conversation-state">
            {#each messages as message (message.id)}
              <div class="message-bubble {message.type}">
                <div class="message-content {message.type}">
                  {#if message.type === "ai"}
                    <div class="ai-header">
                      <div class="ai-icon-wrapper">
                        <img src={extensionIconUrl} alt="Omni Max Logo" />
                      </div>
                      <span class="ai-header-name"
                        >{translations.assistantName}</span
                      >
                    </div>
                  {/if}

                  {#if message.isThinking}
                    <div class="thinking-indicator">
                      <span>{translations.thinking}</span>
                      <div class="thinking-dots">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                      </div>
                    </div>
                  {:else}
                    {@html message.content}
                  {/if}
                </div>
              </div>
            {/each}
          </div>
        {/if}
      </div>

      <div class="composer">
        <div class="composer-input-wrapper">
          <textarea
            bind:this={textareaEl}
            bind:value={inputValue}
            on:keydown={handleTextareaKeyDown}
            on:input={autoResizeTextarea}
            rows="1"
            placeholder={translations.typeYourQuery}
            disabled={isAgentThinking}
          ></textarea>

          <div class="composer-controls">
            <div class="composer-actions">
              <div style="position: relative;">
                <button
                  class="persona-selector-button"
                  on:click={() => (isPersonaPopupOpen = !isPersonaPopupOpen)}
                  title="Selecionar Persona"
                >
                  <span class="button-icon">üë§</span>
                  <span class="button-text">
                    {availablePersonas.find((p) => p.id === selectedPersonaId)
                      ?.name || "Selecionar..."}
                  </span>
                  <ChevronDown class="button-chevron" size={14} />
                </button>

                <PersonaSelectorPopup
                  isOpen={isPersonaPopupOpen}
                  personas={availablePersonas}
                  {selectedPersonaId}
                  onSelect={handlePersonaSelect}
                  onClose={() => (isPersonaPopupOpen = false)}
                />
              </div>
              <button
                class="composer-button-icon"
                on:click={() => (isMCPPopupOpen = true)}
                title="Servidores MCP"
              >
                <Plug size={16} />
              </button>
            </div>
            <div class="composer-actions-right">
              <button
                class="send-button"
                on:click={() => handleSendMessage(inputValue)}
                disabled={!inputValue.trim() || isAgentThinking}
              >
                <ArrowUp size={16} color="white" />
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
{/if}

<MCPServersPopup
  isOpen={isMCPPopupOpen}
  onClose={() => (isMCPPopupOpen = false)}
  {translator}
/>
